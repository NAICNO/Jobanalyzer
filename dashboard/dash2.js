// dashboard.js must have been loaded before this one.

"use strict";

// Colors for annotations
let col_DOWN = "tomato"             // a bit better contrast than "red"
let col_WORKINGHARD = "deepskyblue" // 75%
let col_WORKING = "lightskyblue"    // 50%
let col_COASTING = "lightcyan"      // 25%

// Where to go when clicking on a row, this is opened with ?host=<hostname> from the JSON datum
let machine_page = `machine-detail.html`

let timeout_minutes = 5

// At-a-glance data are generated by naicreport, every 5min ideally.  In addition to the fields
// below there are three fields "recent", "longer", and "long" that give the values of those
// quantities in minutes, and an optional field "tag" that is a human-consumable string that
// briefly describes the data (eg, "ML Nodes" to state that the data are from the ML nodes,
// we assume different clusters have different descriptions).

let fields = [
    // FQDN
    {name: "Host", tag: "hostname"},

    // From the last record on the host.  0=ok, 1=error (maybe more codes later).
    {name: "CPU\nstatus", tag: "cpu_status"},
    {name: "GPU\nstatus", tag: "gpu_status"},

    // Unique users in the period.  This will never be greater than jobs; a user can have
    // several jobs, but not zero, and jobs can only have one user.
    {name: "Users\n(recent)", tag: "users_recent"},
    {name: "Users\n(longer)", tag: "users_longer"},

    // Unique jobs running within the period.
    {name: "Jobs\n(recent)", tag: "jobs_recent"},
    {name: "Jobs\n(longer)", tag: "jobs_longer"},

    // Relative to system information.
    {name: "CPU%\n(recent)", tag: "cpu_recent"},
    {name: "CPU%\n(longer)", tag: "cpu_longer"},
    {name: "Mem%\n(recent)", tag: "mem_recent"},
    {name: "Mem%\n(longer)", tag: "mem_longer"},
    {name: "GPU%\n(recent)", tag: "gpu_recent"},
    {name: "GPU%\n(longer)", tag: "gpu_longer"},
    {name: "GPUMEM%\n(recent)", tag: "gpumem_recent"},
    {name: "GPUMEM%\n(longer)", tag: "gpumem_longer"},

    // Number of new hogs and zombies encountered in the period, as of the last
    // generated report.  This currently changes rarely.
    {name: "Hogs", tag: "hogs_long"},
    {name: "Zombies", tag: "zombies_long"},
]

// Compute field offsets in field table
let offs = {}
for (let i in fields) {
    offs[fields[i].tag] = i
}

let reload_timer = null

function toggleReload() {
    let checked = document.getElementById("autorefresh").checked
    if (!checked && reload_timer != null) {
        clearTimeout(reload_timer)
        reload_timer = null
    } else if (checked && reload_timer == null) {
        reload_timer = setTimeout(function () {
            window.location.reload()
        }, timeout_minutes*60*1000)
    }
}

function setup() {
    toggleReload()
    render()
}

function render() {
    render_table("at-a-glance.json", fields, document.getElementById("report"), sort_records).
	then(annotate_rows)
}

let working_fields = ["cpu_recent","cpu_longer","mem_recent","mem_longer","gpu_recent","gpu_longer","gpumem_recent","gpumem_longer"]

function annotate_rows(rows) {
    // Defaults, updated in the loop
    let recent_minutes = 30
    let longer_minutes = 12*60
    let long_minutes = 24*60
    let tag

    // rows is an array of [json-datum, row-element] pairs
    // each row has exactly the fields above, offsets are computed above too
    for ( let [d,r] of rows ) {
        r.onclick = function () { window.open(`${machine_page}?host=${d["hostname"]}`) }
	if (d["cpu_status"] != 0) {
	    r.style.backgroundColor = col_DOWN
            continue
	}
	if (d["gpu_status"] != 0) {
	    r.children[offs["gpu_status"]].style.backgroundColor = col_DOWN
	}
        for ( let n of working_fields ) {
            switch (true) {
            case d[n] >= 75:
                r.children[offs[n]].style.backgroundColor = col_WORKINGHARD
                break
            case d[n] >= 50:
                r.children[offs[n]].style.backgroundColor = col_WORKING
                break
            case d[n] >= 25:
                r.children[offs[n]].style.backgroundColor = col_COASTING
                break
            }
        }
        recent_minutes = d["recent"]
        longer_minutes = d["longer"]
        long_minutes = d["long"]
        if (tag === undefined) {
            tag = d["tag"]
        }
    }

    document.getElementById("recent_defn").textContent = sanetime(recent_minutes)
    document.getElementById("longer_defn").textContent = sanetime(longer_minutes)
    document.getElementById("long_defn").textContent = sanetime(long_minutes)
    if (tag !== undefined) {
        document.title = tag + " Dashboard"
        document.getElementById("title").textContent = tag + " Dashboard"
    }
}

function sanetime(mins) {
    if (mins < 60) {
        return mins + " mins"
    }
    if (mins % 60 == 0) {
        return (mins / 60) + " hrs"
    }
    return Math.round((mins / 60) * 10) / 10 + " hrs"
}

function sort_records(r1, r2) {
    // failing cpus are sorted higher
    // failing gpus are sorted higher
    // then non-failing systems
    // within each group, by hostname
    if (r1["cpu_status"] != r2["cpu_status"]) {
	return r2["cpu_status"] - r1["cpu_status"]
    }
    if (r1["gpu_status"] != r2["gpu_status"]) {
	return r2["gpu_status"] - r1["gpu_status"]
    }
    if (r1["hostname"] < r2["hostname"]) {
	return -1
    }
    if (r1["hostname"] > r2["hostname"]) {
	return 1
    }
    return 0
}
